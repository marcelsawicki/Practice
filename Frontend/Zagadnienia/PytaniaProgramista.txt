Rozdzial 1.
-----------


Programowanie:
1. Co to jest iteracja?
	Pętla iteracyjna (pętla licznikowa) w programowaniu, 
	to rodzaj pętli, w ramach której następuje wykonanie określonej liczby iteracji. 
	Do kontroli przebiegu wykonania pętli iteracyjnej stosuje się specjalną zmienną, 
	w odniesieniu do której używa się określeń: zmienna sterująca, a także zmienna kontrolna, 
	czy też zmienna licznikowa. W ramach pętli przejście do kolejnej iteracji wiąże się 
	ze zmianą wartości zmiennej sterującej o określoną wielkość i sprawdzenie warunku, 
	czy nowa wartość zmiennej sterującej znajduje się nadal w dopuszczalnym zakresie wartości, 
	określonym dla tej zmiennej w ramach definicji pętli – co jest równoznaczne z powtórzeniem pętli 
	(wykonaniem kolejnej iteracji), czy też wartość ta znajduje się już poza zakresem 
	– co jest równoznaczne z zakończeniem wykonywania pętli i przejściem do wykonania kolejnej 
	– następnej – instrukcji w programie.

Framework .NET:
.NET i C#

2. Co to są typy proste i referencyjne? Jakie są róznice? Gdzie są przechowywane (stos/sterta)?
	
3. Jaka jest różnica między ref a out?
	Najważniejszą i jedyna różnicą jest to, 
	że w przypadku słowa kluczowego „out” argument musi być zainicjowany w ciele metody.

	private void GetOut(out string argOut)
	{
		argOut = string.Empty;
		argOut += "OUT";
	}
	
	Zmienna argtRef jest już zainicjalizowana. 
	Słowo kluczowe „ref” wymaga aby argument przekazywany w ten sposób był już zainicjalizowany.
	private void GetRef(ref string argRef)
	{
		argRef += "REF";
	}
	
	Stad:
	
	public void Main()
	{
		var argRef = "REF";
	 
		GetRef(ref argRef);
	 
		string argOut;
	 
		GetOut(out argOut);
	}
	
	http://blogprogramisty.net/ref-i-out/
	
4. Co oznacza słowo kluczowe np. sealed, partial?
	sealed - (ang. sealed - zapieczętowany) - when applied to a class, the sealed modifier prevents other classes from
	inheriting from it. In the folowing example, calss B inherits from class A, but nop class can inherit from class B.
	
	class A {}
	sealed class B: A {}
	
	additional links: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed
	
5. Co to jest boxing i unboxing?
	
6. Co to jest checked i unchecked?
	Checked i Unchecked - kontrola przepełnień arytmetycznych.

	Instrukcje checked i unchecked służą do kontroli przepełnień arytmetycznych. 
	Instrukcja checked podczas wystąpienia przepełnienia zwraca wyjątek, 
	natomiast instrukcja unchecked nie zwraca wyjątku i ignoruje przepełnienie.
	
	Przykładowy kod instrukcji checked:
	class Przepelnienie
	{
		public static void Main()
		{
			byte x = 150;
			byte y = 12;
			byte z;
	 
			try
			{
				z = checked((byte)(x * y));
			}
			catch (OverflowException)
			{
				Console.WriteLine(„Przepełnienie”);
			}
		}
	}
	
7. Garbage Collector zasada dzialania. Kiedy obiekt jest usuwany z pamięci?
	Garbage Collector - Osoby, które programowały w jezykach obiektowych, takich jak
	np. C++ czy Object Pascal, zastanawiają się zapewne, jak w C# wygląda destruktor i kiedy
	zwalniamy pamięć zarezerwowaną dla obiektów. Skoro bowiem operator new pozwala na
	utworzenie obiektu, a tym samym na zarezerwowanie dla niego pamięci operacyjnej, logicznym
	założeniem jest, że po jego wykorzystaniu pamięć należy zwolnić. Ponieważ jadnak takiego
	podejście, tzn. zrzucenie na barki programistów konieczności zwalniania przydzielonej
	obiektom pamięci, powodowało powstawanie wielu błędów, w nowoczesnych językach
	programowania stosuje się inne rozwiązanie. Otóż za zwalnianie pamięci odpowiada
	środowisko uruchomieniowe, a programista praktycznie nie ma nad tym procesem
	kontroli.
	
	Zajmuje się tym tak zwany odśmiecacz (ang. garbage collector), który czuwa nad 
	optymalnym wykorzystaniem pamięci i uruchami proces jej odzyskiwania w momencie, 
	kiedy wolna ilość oddana do dyspozycji programu zbytnio się zmniejszy. 
	Jest to wyjątkowo wygodne podejście dla programisty, zwalnia bowiem z obowiązku
	zarządzania pamięcią. Zwieksza jednak narzuty czasowe związane z wykorzystaniem 
	programu, wszak sam proces odśmiecania musi zająć czas procesora. Najmniejsze dzisiaj 
	środowiska uruchomieniowe są na tyle dopracowane, że w większości przypadków nie
	ma najmniejszej potrzeby zaprzątania myśli tym problemem.
	
	Trzeba jednak zdawać sobie sprawę, żę środowisko .NET jest w stanie automatycznie
	zarządzać wykorzystaniem pamięci, ale tylko tej, która jest alokowana standardowo,
	czyli za pomocą operatora new. W nielicznych przypadkach, np. w sytuacji,
	gdyby stworzony przez nas biek wykorzystwał jakieś specyficzne zasoby, które nie
	mogą być zwolnione automatycznie, o posprzątanie systemu trzeba zadabać samodzielnie.
	
	W C# w tym celu wykorzystuje się destruktory, które są wykonywane zawsze, kiedy obiekt
	jest niszczony, usuwany z pamięci. Wystarczy więc, jeśli klasa będzie zawierała
	taki destruktor, a przy niszczeniu jej obiektu zostanie on wykonany. W ciele destruktora
	można wykonywać dowolne instrukcje sprzątające. Destruktor deklaruje się tak jak
	konstruktor, z tą różnicą, że nazwy poprzedzamy znakiem tyldy, ogólnie:
	
	class nazwa_klasy
	{
		~nazwa_klasy()
		{
			// kod destruktora
		}
	}
	
	Destruktor należy jednak używać tylko i wyłącznie w sytuacji, kiedy faktycznie
	niezbędne jest zwolnienie alokowanych niestandardowo zasobów. Nie należy natomiast
	umieszczać w kodzie pustych destruktorów, gdyż obniży to wydajność aplikacji.
	
	additional links: https://stackoverflow.com/questions/2926869/do-you-need-to-dispose-of-objects-and-set-them-to-null
	
8. Co to są obiekty immutable?
	Obiekty immutable charakteryzują się tym, że nie można ich prosto zmienić po tym 
	jak zostały stworzone (można na przykład dostać się do samej pamięci, czy też użyć refleksji). 
	Nie ważne ile mają pól i właściwości oraz jakiego są typu. 
	Czasem, potrzebujemy taki obiekt zmienić, wtedy zmieniamy go w całości. 
	Możemy po prostu stworzyć nowy obiekt tej samej klasy mający nowe wartości.
	
9. Wszystko co związane ze stringiem np. konkatencja stringa (StringBuilder)
	A string instance is immutable. You cannot change it after it was created. 
	Any operation that appears to change the string instead returns a new instance:

	string foo = "Foo";
	// returns a new string instance instead of changing the old one
	string bar = foo.Replace('o', 'a');
	string baz = foo + "bar"; // ditto here
	Immutable objects have some nice properties, such as they can be used across threads without 
	fearing synchronization problems or that you can simply hand out your private backing fields 
	directly without fearing that someone changes objects they shouldn't be changing 
	(see arrays or mutable lists, which often need to be copied before returning them if 
	that's not desired). But when used carelessly they may create severe performance problems 
	(as nearly anything – if you need an example from a language that prides itself on 
	speed of execution then look at C's string manipulation functions).

	When you need a mutable string, such as one you're contructing piece-wise or 
	where you change lots of things, then you'll need a StringBuilder which is 
	a buffer of characters that can be changed. This has, for the most part, performance implications.
	 If you want a mutable string and instead do it with a normal string instance, then you'll 
	 end up with creating and destroying lots of objects unnecessarily, whereas a StringBuilder 
	 instance itself will change, negating the need for many new objects.

	Simple example: The following will make many programmers cringe with pain:

	string s = string.Empty;
	for (i = 0; i < 1000; i++) {
	  s += i.ToString() + " ";
	}
	You'll end up creating 2001 strings here, 2000 of which are thrown away. 
	The same example using StringBuilder:

	StringBuilder sb = new StringBuilder();
	for (i = 0; i < 1000; i++) {
	  sb.Append(i);
	  sb.Append(' ');
	}
	This should place much less stress on the memory allocator :-)

	It should be noted however, that the C# compiler is reasonably smart when it comes to strings. 
	For example, the following line

	string foo = "abc" + "def" + "efg" + "hij";
	will be joined by the compiler, leaving only a single string at runtime. 
	Similarly, lines such as

	string foo = a + b + c + d + e + f;
	will be rewritten to

	string foo = string.Concat(a, b, c, d, e, f);
	so you don't have to pay for five nonsensical concatenations which would be the naive
	way of handling that. This won't save you in loops as above 
	(unless the compiler unrolls the loop but I think only 
	the JIT may actually do so and better don't bet on that).

	https://stackoverflow.com/questions/3069416/difference-between-string-and-stringbuilder-in-c-sharp
	
10. Jak działa yield?
	Dzięki niej możemy tworzyć tzw. leniwe kolekcje, 
	do których poszczególne elementy dodawane są dopiero w momencie zgłoszenia na nie zapotrzebowania.

	https://mndevnotes.wordpress.com/2012/08/18/instrukcja-yield-return-tworzenie-leniwych-kolekcji-danych/	
		
11. Co to jest delegat?
	Delegaty to obiekty, które wskazują na dowolne metody znajdujące się w programie. 
	Są definiowane za pomocą słowa kluczowego delegate. 
	Przypominają działanie wskaźników z języka C++, jednak zapewniają kontrolę typów. 
	Mogą wskazywać metody instancyjne oraz statyczne.
	
	https://www.p-programowanie.pl/c-sharp/delegaty/
	
12. Co to są wyrażenia lambda?
	Wyrażenia lamda: 
	W C# 6.0 treść prostych metod może być definiowana w sposób skrócony, za pomocą tzw.
	wyrażeń lambda (ang. lambda expressions). Chociaż głównym celem tych konstrukcji 
	programistycznych jest tworzenie bardziej zaawansowanych funkcjonalności
	takich jak funkcje lokalne (anonimow), ich działanie można pokazać na uproszczonym
	przykładzie dotyczącym właśnie utworzenia metody.
	
	Jeżeli przyjmiemy, że w programie ma postać metoda przyjmująca dwa argumenty i zwracająca
	wynik ich dodawania, to stosując znane do tej pory techniki należałoby użyć konstrukcji
	o następującej postaci (zakładając, że metoda ma się nazywać Dodaj i przyjmować dwa argumenty
	typu Double):
	
	public Double Dodaj(Double arg1, Double arg2)
	{
		return arg1 + arg2;
	}
	
	Zamiast tego można użyć operatora lambda, który ma postać =>. Po lewej stronie
	takiego operatora występuje pewien parametr, a po prawej stronie wyrażenie lub blok instrukcji. 
	Oznacza to, że nasza metoda może wyglądać tak:
	public Double Dodaj(Double arg1, Double arg2) => arg1 + arg2;
	
	Pełny program korzystający z takiej metody mógłby wtedy mieć postać:
	
	using Systeml;
	
	public class Program
	{
		public Double Dodaj(Double arg1, Double arg2) => arg1+ arg2;
		
		public static void Main()
		{
			int liczba1 = 100, liczba2 = 200;
			Program pg = new Program();
			
			Double wynik = pg.Dodaj(liczba1, liczba2);
			Console.WriteLine($"wynik = {wynik}");
		}
	}
		
13. Co to jest serializacja?
	Serializacja – w programowaniu komputerów proces przekształcania obiektów, 
	tj. instancji określonych klas, do postaci szeregowej, czyli w strumień bajtów, 
	z zachowaniem aktualnego stanu obiektu. Serializowany obiekt może zostać utrwalony 
	w pliku dyskowym, przesłany do innego procesu lub innego komputera poprzez sieć. 
	Procesem odwrotnym do serializacji jest deserializacja. 
	Proces ten polega na odczytaniu wcześniej zapisanego strumienia danych i odtworzeniu 
	na tej podstawie obiektu klasy wraz z jego stanem bezpośrednio sprzed serializacji.

	Serializacja służy do zapisu stanu obiektu, a później do odtworzenia jego stanu. 
	
14. Co to jest refleksja?
	Refleksja służy to uzyskania informacji o typie w trakcie wykonywania programu. 
	Klasy, które mają dostęp do metadanych działającego programu są zdefiniowane w przestrzeni 
	nazw System.Reflection.

	Przestrzeń nazw System.Reflection zawiera klasy, które pozwalają na
	uzyskanie informacji o aplikacji oraz pozwalają na dynamiczne dodawanie typów, 
	wartości i obiektów do aplikacji.
		
15. Co to jest atrybut?
	Atrybut – element składni języka programowania, 
	który określa konkretną właściwość (znaczenie), nadaną wybranemu elementowi (obiektowi).
	
16. Co oznacza słowo kluczowe volatile?
	volatile - (ang. volatile - zmienny, niestabilny, lotny)
	
17. Co to jest wątek, co to jest pula wątków? Jak tworzyć wątek?
	
18. Do czego służy słowo lock? Co kryje się pod spodem tego słowa? 
		
19. Inne mechanizmy synchronizacji Mutex, Semaphore, MannualResetEvent, Interlocked
	
20. Co to jest extension method?
	
21. Co to jest lazy loading i eager loading?
		
22. Co to jest Weak Reference?
	
23. Co to jest override i overload?

OOP i wzorce projektowe:

24. Co to jest klasa abstrakcyjna?
 			
25. Co to jest interfejs i czym się różni od klasy abstrakcyjnej?
	Róźnica między interfejsem a klasą abstrakcyjną: 
		
	"Klasy abstrakcyjne
	W wielu przypadkach podstawowa klasa bazowa jest na tyle ogólna, że nie powinno się tworzyć jej obiektu. Tak jak w poprzednim przykładzie, trudno sobie wyobrazić obiekt klasy Animal, gdyż ta klasa opisuje bardzo ogólny typ, który służy jedynie jako nadklasa dla innych, bardziej wyspecjalizowanych klas. Aby zapobiec tworzenia obiektów klas, które są bardzo ogólne i których obiekty nie powinny być tworzone, wprowadzono słowo kluczowe abstract.

	abstract class Animal{}
	var animal = new Animal(); // nie działa, błąd
	Dzięki temu słowu kluczowemu utworzenie egzemplarza klasy Animal nie jest możliwe, służy ona bowiem jedynie jako podstawa dla swoich klas specjalizujących. Klasa abstrakcyjna może zawierać tak jak każda inna klasa atrybuty, metody poprzedzone dowolnymi modyfikatorami. Może również zawierać deklarację (nie definicję) metod abstrakcyjnych.

	abstract class Animal{
		public function goSleep(){
			//chrapie
		}

		abstract public function roar();
	}
	Taki zapis wymusza definicję metody roar() w nieabstrakcyjnej podklasie klasy Animal.

	class Cat extends Animal{
		public function roar(){
			echo 'miał miał';
		}
	}
	Jeśli klasa bazowa jest abstrakcyjna i posiada metodę abstrakcyjną, to nie musi być ona zdefiniowana w kolejnej klasie w hierarchii, ale w takim wypadku klasa która dziedziczy po tej bazowej klasie abstrakcyjnej, musi również być abstrakcyjna.

	abstract class A{
		abstract public function method();
	}

	abstract class B extends A{}//tutaj nie musi być definicja metody A::method()

	class C extends B{//ale tutaj już tak
		public function method(){}
	}
	Modyfikator dostępu w definicji metody abstrakcyjnej nie może być silniejszy od tego pierwotnie zdeklarowanego w klasie abstrakcyjnej, czyli nie można zamienić modyfikatora public na private, ale private na public owszem. Deklaracja metody abstrakcyjnej musi mieć takie same parametry co jej konkretna definicja. Wyjątkiem są parametry z wartością domyślną, nie muszą być one uwzględnione w deklaracji metody abstrakcyjnej, np:

	abstract class A{
		abstract public function method();
	}

	class B extends A{
		public function method($b = false){}//dozwolone
	}

	class C extends A{
		public function method($b){}//niedozwolone!
	}
	Interfejsy
	Jeśli pójdziemy o krok dalej z uogólnieniem pierwszej abstrakcyjnej klasy w hierarchii klas, dojdziemy do momentu kiedy ta klasa będzie zawierała tylko deklaracje abstrakcyjnych metod publicznych. Wtedy taką klasę będziemy mogli zastąpić interfejsem.

	interface iAnimal {
		public function roar();
		//inne abstrakcyjne metody charakterystyczne dla zwierząt
	}

	abstract class Animal implements iAnimal{
		public function goSleep(){
		}
	}
	Jedna klasa może implementować wiele interfejsów, czyli poprawny jest kod:

	interface A {}
	interface B {}
	class C implements A, B {}
	W interfejsie nie musimy korzystać ze słowa kluczowego abstract, aby zdeklarować metodę. Metody, które deklarujemy w interfejsie muszą być publiczne. Pozostałe zasady są takie same jak w metodach abstrakcyjnych.
	"
	
	"Interfejsy po co one są?
	Po co definiować, jakie metody będzie miała klasa? O ile wygodniej napisać samą klasę i po prostu z niej korzystać?
	W praktyce robi się jednak trochę ciekawiej.
	Wyobraź sobie, że masz interfejs ObslugaBazyDanych, a w nim metody "dodajUzytkownika(Uzytkownik) i usunUzytkownik(Uzytkownik).
	Teraz piszesz sobie klasy: ObslugaBazyDanychWPliku implements ObslugaBazyDanych, ObslugaBazySQL implements ObslugaBazyDanych, ObslugaObiektowejBazyDanych implements ObslugaBazyDanych.
	Po pierwsze:
	Jak ktoś kiedyś będzie chciał napisać kolejną wersję obsługi z bazą danych, to od razu narzucisz mu standard, który musi spełnić.
	Po drugie, możesz w dowolnym miejscu w kodzie zrobić:
	ObslugaBazyDanych obd = new <któraś obsługa>();
	obd.dodajUzytkownika(...);
	Niezależnie od tego, którą obsługę wybierzesz (np. w jakiejś fabryce lub zależnie od parametrów użytkownika), to kompilator spokojnie to przepuści i będzie to działać.
	Jeśli dzielisz kod pomiędzy serwer i klienta (EJB, RMI). Wtedy obie strony muszą wiedzieć, jakie metody można wykonać, ale tylko jedna (serwer) ma ciało tych metod.
	
	additional link: https://4programmers.net/Forum/Java/221811-interfejsy_kl_abstrakcyjne_
		
26. Czy klasa abstrakcyjna może zawierać metody nieabstrakcyjne?
		
27. Co to jest metoda wirtualna?
	Metoda wirtualna (funkcja wirtualna) to metoda, której wywołanie jest polimorficzne.
	
	Polimorfizm (z gr. wielopostaciowość) - mechanizmy pozwalające programiście używać wartości, 
	zmiennych i podprogramów na kilka różnych sposobów. 
	Inaczej mówiąc jest to możliwość wyabstrahowania wyrażeń od konkretnych typów.
			
28. Singleton - jak wygląda deklaracja, wady i zalety, jak wygląda bezpieczny wielowątkowy singleton?
	Singleton - Singleton to konstrukcyjny wzorzec projektowy. 
	Wyobraź sobie, że w naszym programie potrzebujemy obiektu, 
	który będzie zainicjowany tylko jeden raz. 
	Tak, ograniczamy się tylko do pojedynczej instancji dla danej klasy. 
	Ale po co komu w ogóle taki obiekt? 
	Załóżmy, że będzie on zawierał w sobie bardzo ważne informacje, 
	może zawierać jakieś statystyki bądź ważne ustawienia. 
	Ponowna inicjalizacja mogłaby spowodować przekłamanie oraz nieumyślną zmianę 
	zapisanych ustawień. Otrzymane wyniki będą niespójne. 
	Kolejnym przykładem zastosowania singletona jest oszczędność pamięci przez programistę. 
	Sam użytkownik nawet nie wie, czy owa instancja już istnieje, czy też nie. 
	W programach wielowątkowych istnieje pewne ryzyko błędu, spowodowanego stosowaniem wzorca. 
	Może dojść do sytuacji, że dwa wątki, w tym samym czasie będą chciały zainicjować obiekt, 
	w skutek czego powstają nam dwa singletony w systemie.
		
29. Fabryka, kiedy stosujemy?
	
30. Strategia, adapter, obserwator, dekorator, 
	
31. Repozytorium, unit of work.

Wzorce prezentacji MVC, MVP, MVVM:

32. Co to jest dependency injection? 
	Wstrzykiwanie zależności (ang. Dependency Injection, DI) – wzorzec projektowy i wzorzec architektury 
	oprogramowania polegający na usuwaniu bezpośrednich zależności pomiędzy komponentami na rzecz 
	architektury typu plug-in. Polega na przekazywaniu gotowych, utworzonych instancji obiektów 
	udostępniających swoje metody i właściwości obiektom, które z nich korzystają 
	(np. jako parametry konstruktora). Stanowi alternatywę do podejścia, 
	gdzie obiekty tworzą instancję obiektów, z których korzystają np. we własnym konstruktorze.
		
33. Co to jest inversion of control?
	Odwrócenie sterowania (ang. Inversion of Control, IoC) – paradygmat 
	(czasami rozważany też jako wzorzec projektowy lub wzorzec architektury) 
	polegający na przeniesieniu funkcji sterowania wykonywaniem programu do używanego frameworku. 
	Framework w odpowiednich momentach wywołuje kod programu stworzony przez programistę w ramach 
	implementacji danej aplikacji. Odbiega to od popularnej metody programowania, gdzie programista 
	tworzy kod aplikacji, który steruje jej zachowaniem. Następnie używa we własnym modelu 
	sterowania bibliotek dostarczonych przez framework.

WPF:

34. Co to jest drzewo prezentacji?
	
35. Co to jest drzwo logiczne?

36. Co oznacza static przed nazwa metody?
	Metoda jest statyczna - mozna ja wywolac przez podanie nazwy klasy, nie trzeba tworzyc
	instancji klasy.
	
37. Praca na modelu widoku bazy danych w serwisie, OData oraz autentykacja.
38. Definiowanie metod.
	Metody definiowane są przez swoją sygnaturę oraz ciało metody.
	Sygnatura metody składa się z:

	typu zwracanego przez metodę
	nazwy metody
	listy typów i nazw parametrów metody
	
JavaScript:

39. Co to jest prototype?
40. Jak sprawdzić czy obiekt ma właściwość klasy (property)?
41. Zaawansowany JavaScript 	
	a) instrukcje warunkowe (if) -> obiekt jest null, undefined - jaka jest roznica?; 
	b) typeof? typy w JavaScript,
  	c) pusta tablica i nie zdefiniowana zmienna majaca przechowywac tablice
	d) iterowanie po danych, funkcja forEach

Analityczne:
42. Mamy 12 kulek, wage szalkową i 3 ważenia. Jedna z kulek ma masę inną od pozostałych kulek. Jak za pomocą wagi i tych 3 ważeń, które mamy do dyspozycji znaleź kulkę która ma inną masę?
43. Jesteśmy w posiadaniu dwóch klepsydr. Jedna przesypuje się w 7 minut, druga 11 minut. Jak odmierzyć dokładnie 15 minut używając wyłącznie tych dwóch klepsydr?


Rozdzial 2.
-----------

1. Co to jest klasa generyczna?
2. Wzorzec projektowy 'Obserwator'.
3. Co to jest 'klucz obcy'?
4. Co to jest 'selektor'?
5. Rozproszone bazy danych, bazy danych Oracle.
6. Czy klasa moze dziedziczyc po wielu klasach?
7. Czy klasa moze implementowac wiele interfejsow?
8. Co oznacza 'sealed'? Nie mozna dziedziczy po tej klasie.
9. Napisac JOIN w SQL.
	SELECT C.Name, P.Name
	FROM [SalesLT].[ProductCategory] AS C
	JOIN [SalesLT].[Product] AS P
	ON P.ProductCategoryID=C.ProductCategoryID;
	
10. Napisac JOIN i wyswietlic 3 rekordy
11. Napisac metode ktora sformatuje zadany string np. 'ZACB' tak zeby byl wyswietlany
	w kolejnosci alfabetycznej.
12. dana jest tablica liczb, napisac metode ktora znajdzie liczbe np. '514'.
13. JavaScript - jak sprawdzic, ze zmienna jest tablica.
14. JavaScript - co daje dopisanie 'use script'.
15. Opisac 'Routing' w ASP.NET MVC i ASP.NET.
16. Blok try, catch - co przechwytuje exception. (catch)
17. Git - do czego sluzy 'rebase'.
18. Klasa abstrakcyjna - wskazac klase ktorej instancji nie mozna utworzyc.
19. Opisac GET i POST.
20. JavaScript - roznica miedzy '==' a '==='.

Rozdzial 3.
-----------

1. Debugowanie warunkowe kodu.
2. SOLID:
	Single responsibility principle (Zasada jednej odpowiedzialności):
	Klasa powinna mieć tylko jedną odpowiedzialność 
	(nigdy nie powinien istnieć więcej niż jeden powód do modyfikacji klasy).
	
	Open/closed principle (Zasada otwarte-zamknięte)
	Klasy (encje) powinny być otwarte na rozszerzenia i zamknięte na modyfikacje.
	
	Liskov substitution principle (Zasada podstawienia Liskov)
	Funkcje które używają wskaźników lub referencji do klas bazowych, 
	muszą być w stanie używać również obiektów klas dziedziczących po klasach bazowych, 
	bez dokładnej znajomości tych obiektów.
	
	Interface segregation principle (Zasada segregacji interfejsów)
	Wiele dedykowanych interfejsów jest lepsze niż jeden ogólny.
	
	Dependency inversion principle (Zasada odwrócenia zależności)
	Wysokopoziomowe moduły nie powinny zależeć od modułów niskopoziomowych 
	- zależności między nimi powinny wynikać z abstrakcji.
	
3. Rekurencja, Rekursja. Jakie jest zagrozenie podczas stosowania rekurencji? StackOverFlow.
	Rekurencja, zwana także rekursją (ang. recursion, z łac. recurrere, przybiec z powrotem) 
	– odwoływanie się np. funkcji lub definicji do samej siebie.
	
4. 'scope' - np. obiekt tworzony w metodzie, jaki jest zasieg?

5. Operator reszty (%) oblicza resztę po podzieleniu

class Reszta
{
    static void Main()
    {
        Console.WriteLine(5 % 2);       // int
        Console.WriteLine(-5 % 2);      // int
        Console.WriteLine(5.0 % 2.2);   // double
        Console.WriteLine(5.0m % 2.2m); // decimal
        Console.WriteLine(-5.2 % 2.0);  // double
    }
}
/*
Output:
1
-1
0.6
0.6
-1.2
*/

GIT - konsola, push i założenie merge request na Gitlabie
SQL i mechanizmy relacyjnej bazy danych - co znaczy “join”, “left join”, “group by”, “having”, indeksy i procedury składowane